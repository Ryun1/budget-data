// Treasury Reserve Contract - Main contract we're tracking
TREASURY_PAYMENT_ADDR = "addr1xxzc8pt7fgf0lc0x7eq6z7z6puhsxmzktna7dluahrj6g6v9swzhujsjlls7dajp59u95re0qdk9vh8mumlemw89535s4ecqxj";
TREASURY_STAKE_ADDR = "stake17xzc8pt7fgf0lc0x7eq6z7z6puhsxmzktna7dluahrj6g6ghh5qjr";
TREASURY_SCRIPT_HASH = "8583857e4a12ffe1e6f641a1785a0f2f036c565cfbe6ff9db8e5a469";

// Initialize known addresses set with treasury address
def initKnownAddresses() {
    addresses = state.get("known_treasury_addresses");
    if (addresses == null) {
        addresses = new java.util.HashSet();
        addresses.add(TREASURY_PAYMENT_ADDR);
        state.put("known_treasury_addresses", addresses);
    }
    return addresses;
}

// Filter UTXOs - only keep those belonging to treasury or vendor contracts with same stake credential
def filterUtxos(items) {
    knownAddrs = initKnownAddresses();
    filtered = new java.util.ArrayList();

    for (item : items) {
        ownerAddr = item.ownerAddr;
        stakeCredential = item.ownerStakeCredential;

        // Check if this is a known treasury address
        if (knownAddrs.contains(ownerAddr)) {
            filtered.add(item);
        }
        // Check if stake credential matches treasury script hash
        // All vendor contracts share the same stake credential as treasury
        else if (stakeCredential != null && stakeCredential.equals(TREASURY_SCRIPT_HASH)) {
            filtered.add(item);
            // Add to known addresses for future lookups
            state.addToSet("known_treasury_addresses", ownerAddr);
        }
    }

    return filtered;
}

// Filter transactions - keep those with TOM metadata
// Note: Transaction inputs are UtxoKey objects (txHash + outputIndex), not full UTXOs with addresses
// So we filter based on metadata presence tracked via post-actions
def filterTransactions(items) {
    txsWithMetadata = state.get("txs_with_tom_metadata");
    if (txsWithMetadata == null) {
        // On first run, allow all transactions until metadata post-action runs
        return items;
    }

    filtered = new java.util.ArrayList();

    for (item : items) {
        txHash = item.txHash;

        // Check if this transaction has TOM metadata (label 1694)
        if (txsWithMetadata.contains(txHash)) {
            filtered.add(item);
        }
    }

    // If no metadata tracked yet, return all items
    if (filtered.isEmpty() && txsWithMetadata.isEmpty()) {
        return items;
    }

    return filtered;
}

// Post-action: When TOM metadata is saved, record the tx hash for transaction filtering
def discoverVendorAddresses(items) {
    for (item : items) {
        // Record this tx hash as having TOM metadata
        state.addToSet("txs_with_tom_metadata", item.txHash);

        // Try to extract vendor addresses from metadata body
        body = item.body;
        if (body != null) {
            // Log for debugging
            System.out.println("TOM Metadata found in tx: " + item.txHash);
        }
    }
}
